/*这个版本整体思想是使用二进制表示每一行种植情况 
1是种了，0是没种  ，101（也就是5）表示种了位置1和3 
然后遍历每行每种二进制情况 ，2的m次方。m是每行几个
然后用动态规划思想，当前行的每一个位置存储：前几行包含这个位置有几种可能
那么到下一行，我只需要对与每一个合法位置 ，判断与上一行每一个合法位置是否可以共存
就能让这个位置存储前几行包含这个位置有几种可能 
最后只需要把最后一行所有位置的可能加起来，就是总的方案数
（一点做题技巧，这题太阴了） 
*/
#include <stdio.h>
#include <stdbool.h>

#define MOD 998244353
#define MAX_ROW 15
// M最大是13，所以状态数最大是 2^13 = 8192，我们开大一点
#define MAX_STATE 9000

int N, M;
int strength[MAX_ROW];          // 每个学院作物的生命力
int weed[MAX_ROW][MAX_ROW];     // 杂草高度
long long dp[MAX_ROW][MAX_STATE]; // DP数组

// 函数1 检查这一行内部是否左右相邻
// 比如 110 (二进制) 也就是 6，左右相邻了，返回 false
// 比如 101 (二进制) 也就是 5，没相邻，返回 true
bool check_zuoyou(int state) {
    // 这里的位运算含义是：如果把状态左移一位再和自己做“与”运算
    // 如果结果不是0，说明有相邻的1
    if ((state & (state << 1)) != 0) {
        return false;
    }
    return true;
}

// 函数2 检查这一行杂草是否生命力是否太高
// row: 第几行, state: 这一行的种植状态，1种了，0没种 
bool check_soil(int row,int state) {
    for (int j=0;j<M;j++) {
        // 检查 state的第j位是不是1
        if ((state >> j) & 1) {
            // 如果这一格种了作物，但作物生命力 <= 杂草高度
            // 注意：输入是从第1行存的，但列j是从0开始循环的，这里要注意对应
            if (strength[row] <= weed[row][j + 1]) {
                return false;
            }
        }
    }
    return true;
}

int main() {
    // 1. 输入数据
    scanf("%d%d", &N,&M);

    for (int i=1;i<=N;i++) {
        scanf("%d",&strength[i]);
    }

    for (int i=1;i<=N;i++) {
        for (int j=1;j<=M;j++) {
            scanf("%d",&weed[i][j]);
        }
    }

    // 这一行有多少种可能的状态？2的M次方
    // 比如 M=3状态就是000到111(0到7)，8种
    int max_state_val = 1 << M; 

    // 2. 初始化第 0 行（虚拟行）
    // 第0行什么都不种（状态为0），方案数为1，这是为了方便推导第1行
    dp[0][0] = 1;

    // 3. 开始一行一行地处理
    for (int i =1;i<=N;i++) {
        
        // 遍历当前行所有可能的状态 
        for (int now=0;now<max_state_val;now++) {
            //这里now和下面pre都是用它的二进制表示种植情况 
            
            // 如果这一行自己左右相邻，那肯定不行，直接跳过
            if (!check_zuoyou(now)) continue;

            // 如果这一行种在了杂草太高的地方，也不行，跳过
            if (!check_soil(i, now)) continue;

            // 如果当前行的 now 状态是合法的，那就去看看上一行的状态 (pre)
            for (int pre = 0; pre < max_state_val; pre++) {
                

                // 检查上下是否相邻
                // 如果 (now & pre) 不等于 0，说明某一列上下同时种了（都是1），冲突了
                if ((now & pre) == 0) {
                    // 状态转移：当前方案数 += 上一行的方案数
                    dp[i][now] = (dp[i][now] + dp[i-1][pre]) % MOD;
                }
            }
        }
    }

    // 4. 统计结果
    // 答案就是最后一行（第 N 行）所有合法状态的方案数之和
    long long ans = 0;
    for (int s=0;s<max_state_val;s++) {
        ans = (ans+dp[N][s])%MOD;
    }

    printf("%lld\n",ans);

    return 0;
}
