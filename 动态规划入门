#include<stdio.h>
int min(int a,int b){//比较
	return a<b?a:b;
}
int main(){
	
	int n,m;
	scanf("%d%d",&n,&m);
	int arr[n][m];
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			scanf("%d",&arr[i][j]); 
		}
	}//录入n*m矩阵
  
	int dp[n][m]={0};
	dp[0][0]=arr[0][0]; 
	for(int i=1;i<n;i++){
		dp[i][0]=dp[i-1][0]+arr[i][0];
	}
		for(int j=1;j<m;j++){
			dp[0][j]=dp[0][j-1]+arr[0][j];
		}
  //记录横竖初始状态，因为涉及路径，只有一种可能，直接初始化
		
	for(int i=1;i<n;i++){
		for(int j=1;j<m;j++){
			dp[i][j]=arr[i][j]+min(dp[i][j-1],dp[i-1][j]);
			if(dp[i][j-1]>dp[i-1][j])printf("(%d,%d)\n",i-1,j);
			else printf("(%d,%d)\n",i,j-1);
			//printf("%d\n",dp[i][j]);
		}
	}
  //这一步是核心，用dp记录当前路径最优解，然后比较递推下一步最优
printf("%d",dp[n-1][m-1]);//最后输出
	return 0;
}
//补充：如果要得到路径，可以再定义一个二维数组记录上一步从哪个方向来的，最后逆推出路径
